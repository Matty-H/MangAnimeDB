datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "darwin-arm64","rhel-openssl-1.0.x"]
}

// This is your Prisma schema file
// Learn more about it in the docs: https:

model License {
  id               String      @id @default(cuid())
  externalId       String?     @unique //Pour FMA001, DN001, etc.
  title            String
  mangas           MangaWork[] @relation(name: "LicenseToManga")
  animeAdaptations AnimeWork[] @relation(name: "AnimeAdaptationToLicense")
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt

  @@map("licenses")
}

model MangaWork {
  id          String         @id @default(cuid())
  externalId  String?        @unique //Pour FMA301, DN301, etc.
  licenseId   String
  license     License        @relation(name: "LicenseToManga", fields: [licenseId], references: [id], onDelete: Cascade)
  authors     String[]
  volumes     Int
  status      WorkStatus
  startDate   DateTime?
  endDate     DateTime?
  publisher   String
  adaptations MangaToAnime[] @relation(name: "MangaToMangaToAnime")
  createdAt   DateTime       @default(now())
  updatedAt   DateTime       @updatedAt

  @@map("mangas")
}

model AnimeWork {
  id           String         @id @default(cuid())
  externalId   String?        @unique //Pour FMA302, DN302, etc.
  licenseId    String
  license      License        @relation(name: "AnimeAdaptationToLicense", fields: [licenseId], references: [id], onDelete: Cascade)
  title        String
  studio       String
  episodes     Int
  startDate    DateTime?
  endDate      DateTime?
  status       WorkStatus
  fidelity     AnimeFidelity
  notes        String?        @db.Text
  relationType RelationType
  seasons      AnimeSeason[]  @relation(name: "AnimeAdaptationToAnimeSeason")
  sourcedFrom  MangaToAnime[] @relation(name: "AnimeAdaptationToMangaToAnime")
  createdAt    DateTime       @default(now())
  updatedAt    DateTime       @updatedAt

  @@map("anime_adaptations")
}

// Table interm√©diaire pour la relation many-to-many entre Manga et AnimeAdaptation

model MangaToAnime {
  id                 String    @id @default(cuid())
  mangaId            String
  manga_name         MangaWork @relation(name: "MangaToMangaToAnime", fields: [mangaId], references: [id], onDelete: Cascade)
  animeAdaptationId  String
  anime_name         AnimeWork @relation(name: "AnimeAdaptationToMangaToAnime", fields: [animeAdaptationId], references: [id], onDelete: Cascade)
  coverageFromVolume Int?
  coverageToVolume   Int?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  @@unique([mangaId, animeAdaptationId])
  @@map("manga_to_anime")
}

model AnimeSeason {
  id                 String        @id @default(cuid())
  animeAdaptationId  String
  animeAdaptation    AnimeWork     @relation(name: "AnimeAdaptationToAnimeSeason", fields: [animeAdaptationId], references: [id], onDelete: Cascade)
  seasonNumber       Int
  episodes           Int
  fidelity           AnimeFidelity
  coverageFromVolume Int?
  coverageToVolume   Int?
  notes              String?       @db.Text
  relationType       RelationType?
  createdAt          DateTime      @default(now())
  updatedAt          DateTime      @updatedAt

  @@map("anime_seasons")
}

enum WorkStatus {
  ONGOING
  COMPLETED
  HIATUS
  UNFINISHED
}

enum AnimeFidelity {
  FAITHFUL
  PARTIAL
  ANIME_ORIGINAL
}

enum RelationType {
  ORIGINAL
  SEQUEL
  PREQUEL
  REMAKE
  SPIN_OFF
  REBOOT
}
